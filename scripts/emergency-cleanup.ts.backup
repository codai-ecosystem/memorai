#!/usr/bin/env node

/**
 * Emergency Memory Cleanup and Optimization Script
 * Addresses the 45GB memory issue immediately
 */

import { QdrantClient } from '@qdrant/js-client-rest';

class EmergencyMemoryCleanup {
    private qdrantClient: QdrantClient;
    private collectionName: string;

    constructor() {
        this.qdrantClient = new QdrantClient({
            url: process.env.QDRANT_URL || 'http://localhost:6333',
            apiKey: process.env.QDRANT_API_KEY
        });
        this.collectionName = process.env.QDRANT_COLLECTION || 'memories';
    }

    async run() {
        console.log('üö® Starting Emergency Memory Cleanup...');
        console.log('üìä Analyzing current memory usage...');

        try {
            // Step 1: Get current collection stats
            const stats = await this.getCollectionStats();
            console.log(`üìà Current collection stats:`, stats);

            // Step 2: Remove old and unused memories
            console.log('üßπ Removing old memories (>60 days)...');
            const oldRemoved = await this.removeOldMemories();
            console.log(`‚úÖ Removed ${oldRemoved} old memories`);

            // Step 3: Remove low-access memories
            console.log('üóëÔ∏è  Removing low-access memories...');
            const lowAccessRemoved = await this.removeLowAccessMemories();
            console.log(`‚úÖ Removed ${lowAccessRemoved} low-access memories`);

            // Step 4: Remove exact duplicates
            console.log('üîç Removing duplicate memories...');
            const duplicatesRemoved = await this.removeDuplicates();
            console.log(`‚úÖ Removed ${duplicatesRemoved} duplicate memories`);

            // Step 5: Optimize collection
            console.log('‚ö° Optimizing collection structure...');
            await this.optimizeCollection();
            console.log(`‚úÖ Collection optimization completed`);

            // Step 6: Get final stats
            const finalStats = await this.getCollectionStats();
            console.log(`üìâ Final collection stats:`, finalStats);

            const sizeDiff = stats.vectors_count - finalStats.vectors_count;
            const percentReduction = ((sizeDiff / stats.vectors_count) * 100).toFixed(2);

            console.log(`üéâ Cleanup completed!`);
            console.log(`üìä Removed ${sizeDiff} memories (${percentReduction}% reduction)`);
            console.log(`üíæ Estimated space saved: ~${this.estimateSpaceSaved(sizeDiff)}GB`);

        } catch (error) {
            console.error('‚ùå Emergency cleanup failed:', error);
            process.exit(1);
        }
    }

    private async getCollectionStats() {
        try {
            const info = await this.qdrantClient.getCollection(this.collectionName);
            return info;
        } catch (error) {
            console.warn('Could not get collection stats:', error);
            return { vectors_count: 0, points_count: 0 };
        }
    }

    private async removeOldMemories(): Promise<number> {
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - 60); // 60 days ago

        const scrollResult = await this.qdrantClient.scroll(this.collectionName, {
            filter: {
                must: [
                    {
                        key: 'created_at',
                        range: {
                            lt: cutoffDate.toISOString()
                        }
                    }
                ]
            },
            limit: 10000,
            with_payload: false,
            with_vector: false
        });

        if (scrollResult.points.length > 0) {
            const ids = scrollResult.points.map(p => p.id);
            await this.qdrantClient.delete(this.collectionName, {
                points: ids,
                wait: true
            });
            return ids.length;
        }

        return 0;
    }

    private async removeLowAccessMemories(): Promise<number> {
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - 21); // 3 weeks ago

        const scrollResult = await this.qdrantClient.scroll(this.collectionName, {
            filter: {
                must: [
                    {
                        key: 'access_count',
                        range: {
                            lt: 2 // Less than 2 accesses
                        }
                    },
                    {
                        key: 'created_at',
                        range: {
                            lt: cutoffDate.toISOString()
                        }
                    },
                    {
                        key: 'importance',
                        range: {
                            lt: 0.5 // Low importance
                        }
                    }
                ]
            },
            limit: 10000,
            with_payload: false,
            with_vector: false
        });

        if (scrollResult.points.length > 0) {
            const ids = scrollResult.points.map(p => p.id);
            await this.qdrantClient.delete(this.collectionName, {
                points: ids,
                wait: true
            });
            return ids.length;
        }

        return 0;
    }

    private async removeDuplicates(): Promise<number> {
        console.log('üîç Scanning for duplicates (this may take a while)...');

        const allPoints = await this.getAllPoints();
        const duplicates: string[] = [];
        const seen = new Map<string, string>();

        for (const point of allPoints) {
            const contentHash = point.payload?.content_hash as string;
            if (!contentHash) continue;

            const existing = seen.get(contentHash);
            if (existing) {
                // Keep the one with higher access count or newer date
                const existingPoint = allPoints.find(p => p.id === existing);
                const currentAccess = (point.payload?.access_count as number) || 0;
                const existingAccess = (existingPoint?.payload?.access_count as number) || 0;

                if (currentAccess > existingAccess) {
                    duplicates.push(existing);
                    seen.set(contentHash, point.id as string);
                } else {
                    duplicates.push(point.id as string);
                }
            } else {
                seen.set(contentHash, point.id as string);
            }
        }

        if (duplicates.length > 0) {
            // Remove duplicates in batches
            const batchSize = 1000;
            let removed = 0;

            for (let i = 0; i < duplicates.length; i += batchSize) {
                const batch = duplicates.slice(i, i + batchSize);
                await this.qdrantClient.delete(this.collectionName, {
                    points: batch,
                    wait: true
                });
                removed += batch.length;
                console.log(`üóëÔ∏è  Removed ${removed}/${duplicates.length} duplicates...`);
            }
        }

        return duplicates.length;
    }

    private async getAllPoints() {
        const allPoints: any[] = [];
        let offset = undefined;

        do {
            const scrollResult = await this.qdrantClient.scroll(this.collectionName, {
                limit: 10000,
                with_payload: true,
                with_vector: false,
                offset
            });

            allPoints.push(...scrollResult.points);
            offset = scrollResult.next_page_offset;
        } while (offset);

        return allPoints;
    }

    private async optimizeCollection(): Promise<void> {
        try {
            // Update collection configuration for better performance
            await this.qdrantClient.updateCollection(this.collectionName, {
                optimizers_config: {
                    deleted_threshold: 0.1, // More aggressive cleanup
                    vacuum_min_vector_number: 100,
                    default_segment_number: 4,
                    max_segment_size: 20000,
                    memmap_threshold: 50000,
                    indexing_threshold: 20000,
                    flush_interval_sec: 5,
                    max_optimization_threads: 2
                }
            });

            console.log('‚úÖ Collection configuration updated for optimization');
        } catch (error) {
            console.warn('Collection optimization update failed:', error);
        }
    }

    private estimateSpaceSaved(memoriesRemoved: number): string {
        // Rough estimation: each memory ~= 2KB (content + embedding + metadata)
        const avgMemorySize = 2 * 1024; // 2KB
        const totalBytes = memoriesRemoved * avgMemorySize;
        const totalGB = totalBytes / (1024 * 1024 * 1024);
        return totalGB.toFixed(2);
    }
}

// Run the cleanup
const cleanup = new EmergencyMemoryCleanup();
cleanup.run().catch(console.error);
