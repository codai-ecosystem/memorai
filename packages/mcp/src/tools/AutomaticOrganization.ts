/**
 * MCP v3.0 - Automatic Organization
 * AI-powered automatic memory organization, categorization, and structure optimization
 */

// MCP v3.0 types - will be integrated with main types
interface Memory {
  id: string;
  content: string;
  type: string;
  timestamp: number;
  metadata?: Record<string, any>;
}

export interface OrganizationRule {
  id: string;
  name: string;
  condition: {
    type: 'content' | 'metadata' | 'temporal' | 'behavioral' | 'pattern';
    field: string;
    operator:
      | 'contains'
      | 'equals'
      | 'matches'
      | 'greater'
      | 'less'
      | 'in_range';
    value: any;
  };
  action: {
    type: 'categorize' | 'tag' | 'move' | 'archive' | 'link' | 'prioritize';
    parameters: Record<string, any>;
  };
  priority: number;
  enabled: boolean;
  confidence: number;
}

export interface Category {
  id: string;
  name: string;
  description: string;
  parentId?: string;
  children: string[];
  memoryCount: number;
  autoGenerated: boolean;
  rules: string[];
  metadata: Record<string, any>;
}

export interface TagSuggestion {
  tag: string;
  confidence: number;
  reasoning: string;
  frequency: number;
  relatedTags: string[];
}

export interface OrganizationInsight {
  type: 'duplicate' | 'orphan' | 'cluster' | 'pattern' | 'gap';
  description: string;
  memoryIds: string[];
  severity: 'low' | 'medium' | 'high';
  recommendation: string;
  autoFixAvailable: boolean;
}

export interface OrganizationStats {
  totalMemories: number;
  categorizedMemories: number;
  taggedMemories: number;
  orphanedMemories: number;
  duplicateMemories: number;
  organizationScore: number; // 0-1 scale
  lastOrganized: number;
}

export class AutomaticOrganization {
  private categories: Map<string, Category> = new Map();
  private organizationRules: Map<string, OrganizationRule> = new Map();
  private memories: Map<string, Memory> = new Map();
  private tagIndex: Map<string, Set<string>> = new Map(); // tag -> memoryIds
  private contentIndex: Map<string, Set<string>> = new Map(); // keyword -> memoryIds
  private organizationHistory: Array<{
    timestamp: number;
    action: string;
    memoryIds: string[];
  }> = [];

  constructor(
    private autoOrganizeInterval: number = 1000 * 60 * 60, // 1 hour
    private minCategorySize: number = 5,
    private maxCategories: number = 50,
    private confidenceThreshold: number = 0.7
  ) {
    this.initializeDefaultCategories();
    this.initializeDefaultRules();
    this.startAutoOrganization();
  }

  /**
   * Automatically organize all memories
   */
  async organizeMemories(memories: Memory[]): Promise<{
    organized: number;
    categorized: number;
    tagged: number;
    insights: OrganizationInsight[];
    stats: OrganizationStats;
  }> {
    // Update memory index
    for (const memory of memories) {
      this.memories.set(memory.id, memory);
      this.indexMemoryContent(memory);
    }

    let organized = 0;
    let categorized = 0;
    let tagged = 0;

    // Apply organization rules
    for (const memory of memories) {
      const applied = await this.applyOrganizationRules(memory);
      organized += applied;

      // Auto-categorize
      const category = await this.autoCategorizeMem(memory);
      if (category) {
        categorized++;
        organized++;
      }

      // Auto-tag
      const tags = await this.autoTagMemory(memory);
      if (tags.length > 0) {
        tagged++;
        organized++;
      }
    }

    // Generate categories from clusters
    const newCategories = await this.generateCategoriesFromClusters(memories);
    categorized += newCategories;

    // Analyze and generate insights
    const insights = await this.analyzeOrganization(memories);

    // Calculate statistics
    const stats = this.calculateOrganizationStats(memories);

    return {
      organized,
      categorized,
      tagged,
      insights,
      stats,
    };
  }

  /**
   * Auto-categorize a single memory
   */
  async autoCategorizeMem(memory: Memory): Promise<string | null> {
    const scores = new Map<string, number>();

    // Score against existing categories
    for (const [categoryId, category] of this.categories) {
      const score = await this.calculateCategoryScore(memory, category);
      if (score > this.confidenceThreshold) {
        scores.set(categoryId, score);
      }
    }

    // Find best category
    let bestCategory: string | null = null;
    let bestScore = 0;

    for (const [categoryId, score] of scores) {
      if (score > bestScore) {
        bestScore = score;
        bestCategory = categoryId;
      }
    }

    // Assign to category
    if (bestCategory) {
      await this.assignMemoryToCategory(memory.id, bestCategory);
      return bestCategory;
    }

    // Try to create new category if no good match
    const newCategory = await this.suggestNewCategory(memory);
    if (newCategory) {
      const categoryId = await this.createCategory(newCategory);
      await this.assignMemoryToCategory(memory.id, categoryId);
      return categoryId;
    }

    return null;
  }

  /**
   * Auto-tag a memory with relevant tags
   */
  async autoTagMemory(memory: Memory): Promise<string[]> {
    const suggestions = await this.generateTagSuggestions(memory);
    const tags: string[] = [];

    for (const suggestion of suggestions) {
      if (suggestion.confidence > this.confidenceThreshold) {
        tags.push(suggestion.tag);
        await this.addTagToMemory(memory.id, suggestion.tag);
      }
    }

    return tags;
  }

  /**
   * Generate tag suggestions for a memory
   */
  async generateTagSuggestions(memory: Memory): Promise<TagSuggestion[]> {
    const suggestions: TagSuggestion[] = [];

    // Extract keywords from content
    const keywords = this.extractKeywords(memory.content);

    for (const keyword of keywords) {
      if (keyword.length > 2) {
        const confidence = this.calculateTagConfidence(keyword, memory);
        const frequency = this.getTagFrequency(keyword);
        const relatedTags = this.getRelatedTags(keyword);

        suggestions.push({
          tag: keyword,
          confidence,
          reasoning: `Extracted from content analysis`,
          frequency,
          relatedTags,
        });
      }
    }

    // Generate semantic tags
    const semanticTags = await this.generateSemanticTags(memory);
    suggestions.push(...semanticTags);

    // Generate temporal tags
    const temporalTags = this.generateTemporalTags(memory);
    suggestions.push(...temporalTags);

    // Generate behavioral tags
    const behavioralTags = this.generateBehavioralTags(memory);
    suggestions.push(...behavioralTags);

    // Sort by confidence and remove duplicates
    return this.deduplicateTagSuggestions(suggestions)
      .sort((a, b) => b.confidence - a.confidence)
      .slice(0, 10);
  }

  /**
   * Generate categories from memory clusters
   */
  async generateCategoriesFromClusters(memories: Memory[]): Promise<number> {
    const clusters = await this.clusterMemories(memories);
    let categoriesCreated = 0;

    for (const cluster of clusters) {
      if (cluster.memories.length >= this.minCategorySize) {
        const categoryName = this.generateCategoryName(cluster);
        const categoryId = await this.createCategory({
          name: categoryName,
          description: `Auto-generated from ${cluster.memories.length} related memories`,
          autoGenerated: true,
          memoryIds: cluster.memories.map(m => m.id),
        });

        // Assign memories to category
        for (const memory of cluster.memories) {
          await this.assignMemoryToCategory(memory.id, categoryId);
        }

        categoriesCreated++;
      }
    }

    return categoriesCreated;
  }

  /**
   * Cluster memories based on similarity
   */
  private async clusterMemories(memories: Memory[]): Promise<
    Array<{
      centroid: string[];
      memories: Memory[];
      similarity: number;
    }>
  > {
    const clusters: Array<{
      centroid: string[];
      memories: Memory[];
      similarity: number;
    }> = [];

    // Simple keyword-based clustering
    const memoryKeywords = memories.map(memory => ({
      memory,
      keywords: this.extractKeywords(memory.content),
    }));

    const processed = new Set<string>();

    for (const { memory, keywords } of memoryKeywords) {
      if (processed.has(memory.id)) continue;

      const cluster = {
        centroid: keywords,
        memories: [memory],
        similarity: 1.0,
      };

      // Find similar memories
      for (const {
        memory: otherMemory,
        keywords: otherKeywords,
      } of memoryKeywords) {
        if (otherMemory.id === memory.id || processed.has(otherMemory.id))
          continue;

        const similarity = this.calculateKeywordSimilarity(
          keywords,
          otherKeywords
        );
        if (similarity > 0.5) {
          cluster.memories.push(otherMemory);
          cluster.similarity = Math.min(cluster.similarity, similarity);
          processed.add(otherMemory.id);
        }
      }

      if (cluster.memories.length >= this.minCategorySize) {
        clusters.push(cluster);
        for (const mem of cluster.memories) {
          processed.add(mem.id);
        }
      }
    }

    return clusters.sort((a, b) => b.memories.length - a.memories.length);
  }

  /**
   * Apply organization rules to a memory
   */
  private async applyOrganizationRules(memory: Memory): Promise<number> {
    let rulesApplied = 0;

    const sortedRules = Array.from(this.organizationRules.values())
      .filter(rule => rule.enabled)
      .sort((a, b) => b.priority - a.priority);

    for (const rule of sortedRules) {
      const matches = await this.evaluateRule(memory, rule);
      if (matches && rule.confidence > this.confidenceThreshold) {
        await this.executeRuleAction(memory, rule);
        rulesApplied++;
      }
    }

    return rulesApplied;
  }

  /**
   * Evaluate if a memory matches a rule condition
   */
  private async evaluateRule(
    memory: Memory,
    rule: OrganizationRule
  ): Promise<boolean> {
    const { condition } = rule;

    let value: any;
    switch (condition.type) {
      case 'content':
        value = memory.content;
        break;
      case 'metadata':
        value = memory.metadata?.[condition.field];
        break;
      case 'temporal':
        value = memory.timestamp;
        break;
      case 'behavioral':
        value = this.getBehavioralMetric(memory, condition.field);
        break;
      case 'pattern':
        value = await this.getPatternValue(memory, condition.field);
        break;
      default:
        return false;
    }

    return this.evaluateCondition(value, condition.operator, condition.value);
  }

  /**
   * Execute a rule action on a memory
   */
  private async executeRuleAction(
    memory: Memory,
    rule: OrganizationRule
  ): Promise<void> {
    const { action } = rule;

    switch (action.type) {
      case 'categorize':
        await this.assignMemoryToCategory(
          memory.id,
          action.parameters.categoryId
        );
        break;
      case 'tag':
        await this.addTagToMemory(memory.id, action.parameters.tag);
        break;
      case 'move':
        await this.moveMemory(memory.id, action.parameters.destination);
        break;
      case 'archive':
        await this.archiveMemory(memory.id);
        break;
      case 'link':
        await this.linkMemories(memory.id, action.parameters.targetId);
        break;
      case 'prioritize':
        await this.setMemoryPriority(memory.id, action.parameters.priority);
        break;
    }

    this.recordOrganizationAction(action.type, [memory.id]);
  }

  /**
   * Analyze organization and generate insights
   */
  private async analyzeOrganization(
    memories: Memory[]
  ): Promise<OrganizationInsight[]> {
    const insights: OrganizationInsight[] = [];

    // Find duplicates
    const duplicates = await this.findDuplicateMemories(memories);
    if (duplicates.length > 0) {
      insights.push({
        type: 'duplicate',
        description: `Found ${duplicates.length} potential duplicate memories`,
        memoryIds: duplicates,
        severity: 'medium',
        recommendation: 'Review and merge duplicate memories',
        autoFixAvailable: true,
      });
    }

    // Find orphaned memories
    const orphans = this.findOrphanedMemories(memories);
    if (orphans.length > 0) {
      insights.push({
        type: 'orphan',
        description: `${orphans.length} memories are uncategorized`,
        memoryIds: orphans,
        severity: 'low',
        recommendation: 'Categorize orphaned memories',
        autoFixAvailable: true,
      });
    }

    // Find dense clusters
    const clusters = await this.findDenseClusters(memories);
    for (const cluster of clusters) {
      insights.push({
        type: 'cluster',
        description: `Dense cluster of ${cluster.length} related memories`,
        memoryIds: cluster,
        severity: 'low',
        recommendation: 'Consider creating a category for this cluster',
        autoFixAvailable: true,
      });
    }

    // Find organizational gaps
    const gaps = this.findOrganizationalGaps(memories);
    insights.push(...gaps);

    return insights.sort((a, b) => {
      const severityOrder = { high: 3, medium: 2, low: 1 };
      return severityOrder[b.severity] - severityOrder[a.severity];
    });
  }

  /**
   * Calculate organization statistics
   */
  private calculateOrganizationStats(memories: Memory[]): OrganizationStats {
    const totalMemories = memories.length;
    const categorizedMemories = memories.filter(m =>
      this.getMemoryCategory(m.id)
    ).length;
    const taggedMemories = memories.filter(
      m => this.getMemoryTags(m.id).length > 0
    ).length;
    const orphanedMemories = this.findOrphanedMemories(memories).length;

    // Estimate duplicates (simplified)
    const duplicateMemories = Math.floor(totalMemories * 0.05); // Assume 5% duplicates

    // Calculate organization score
    const categorizationScore = categorizedMemories / totalMemories;
    const taggingScore = taggedMemories / totalMemories;
    const orphanPenalty = orphanedMemories / totalMemories;
    const duplicatePenalty = duplicateMemories / totalMemories;

    const organizationScore = Math.max(
      0,
      categorizationScore * 0.4 +
        taggingScore * 0.3 -
        (orphanPenalty * 0.2 + duplicatePenalty * 0.1)
    );

    return {
      totalMemories,
      categorizedMemories,
      taggedMemories,
      orphanedMemories,
      duplicateMemories,
      organizationScore,
      lastOrganized: Date.now(),
    };
  }

  // Helper methods

  private initializeDefaultCategories(): void {
    const defaultCategories = [
      { name: 'Projects', description: 'Work and personal projects' },
      { name: 'Research', description: 'Research notes and findings' },
      { name: 'Meetings', description: 'Meeting notes and recordings' },
      { name: 'Ideas', description: 'Creative ideas and inspirations' },
      { name: 'Personal', description: 'Personal thoughts and reflections' },
      { name: 'Technical', description: 'Technical documentation and code' },
      { name: 'Learning', description: 'Educational content and notes' },
    ];

    for (const category of defaultCategories) {
      const id = this.generateId();
      this.categories.set(id, {
        id,
        name: category.name,
        description: category.description,
        children: [],
        memoryCount: 0,
        autoGenerated: false,
        rules: [],
        metadata: {},
      });
    }
  }

  private initializeDefaultRules(): void {
    const defaultRules: Omit<OrganizationRule, 'id'>[] = [
      {
        name: 'Project Categorization',
        condition: {
          type: 'content',
          field: 'content',
          operator: 'contains',
          value: ['project', 'task', 'deadline', 'milestone'],
        },
        action: {
          type: 'categorize',
          parameters: { categoryId: this.findCategoryByName('Projects') },
        },
        priority: 8,
        enabled: true,
        confidence: 0.8,
      },
      {
        name: 'Meeting Notes',
        condition: {
          type: 'content',
          field: 'content',
          operator: 'contains',
          value: ['meeting', 'agenda', 'minutes', 'attendees'],
        },
        action: {
          type: 'categorize',
          parameters: { categoryId: this.findCategoryByName('Meetings') },
        },
        priority: 9,
        enabled: true,
        confidence: 0.85,
      },
      {
        name: 'Technical Content',
        condition: {
          type: 'content',
          field: 'content',
          operator: 'contains',
          value: ['code', 'function', 'api', 'algorithm', 'database'],
        },
        action: {
          type: 'categorize',
          parameters: { categoryId: this.findCategoryByName('Technical') },
        },
        priority: 7,
        enabled: true,
        confidence: 0.75,
      },
    ];

    for (const rule of defaultRules) {
      const id = this.generateId();
      this.organizationRules.set(id, { ...rule, id });
    }
  }

  private indexMemoryContent(memory: Memory): void {
    const keywords = this.extractKeywords(memory.content);

    for (const keyword of keywords) {
      if (!this.contentIndex.has(keyword)) {
        this.contentIndex.set(keyword, new Set());
      }
      this.contentIndex.get(keyword)!.add(memory.id);
    }
  }

  private extractKeywords(content: string): string[] {
    return content
      .toLowerCase()
      .split(/\W+/)
      .filter(word => word.length > 2 && !this.isStopWord(word))
      .slice(0, 20); // Limit keywords
  }

  private isStopWord(word: string): boolean {
    const stopWords = new Set([
      'the',
      'a',
      'an',
      'and',
      'or',
      'but',
      'in',
      'on',
      'at',
      'to',
      'for',
      'of',
      'with',
      'by',
      'is',
      'are',
      'was',
      'were',
      'be',
      'been',
      'have',
      'has',
      'had',
      'do',
      'does',
      'did',
      'will',
      'would',
      'could',
      'should',
    ]);
    return stopWords.has(word);
  }

  private async calculateCategoryScore(
    memory: Memory,
    category: Category
  ): Promise<number> {
    let score = 0;

    // Keyword matching
    const memoryKeywords = this.extractKeywords(memory.content);
    const categoryKeywords = this.extractKeywords(category.description);
    const keywordOverlap = memoryKeywords.filter(k =>
      categoryKeywords.includes(k)
    ).length;
    score += (keywordOverlap / Math.max(memoryKeywords.length, 1)) * 0.5;

    // Existing member similarity
    const categoryMemories = this.getCategoryMemories(category.id);
    if (categoryMemories.length > 0) {
      let similaritySum = 0;
      for (const catMemory of categoryMemories) {
        const similarity = this.calculateContentSimilarity(memory, catMemory);
        similaritySum += similarity;
      }
      score += (similaritySum / categoryMemories.length) * 0.5;
    }

    return Math.min(score, 1.0);
  }

  private calculateContentSimilarity(memory1: Memory, memory2: Memory): number {
    const keywords1 = this.extractKeywords(memory1.content);
    const keywords2 = this.extractKeywords(memory2.content);
    return this.calculateKeywordSimilarity(keywords1, keywords2);
  }

  private calculateKeywordSimilarity(
    keywords1: string[],
    keywords2: string[]
  ): number {
    const set1 = new Set(keywords1);
    const set2 = new Set(keywords2);
    const intersection = new Set([...set1].filter(k => set2.has(k)));
    const union = new Set([...set1, ...set2]);

    return union.size > 0 ? intersection.size / union.size : 0;
  }

  private async suggestNewCategory(memory: Memory): Promise<{
    name: string;
    description: string;
    autoGenerated: boolean;
    memoryIds: string[];
  } | null> {
    const keywords = this.extractKeywords(memory.content);
    const dominantKeyword = keywords[0];

    if (dominantKeyword && this.categories.size < this.maxCategories) {
      return {
        name: this.capitalizeFirst(dominantKeyword),
        description: `Auto-generated category for ${dominantKeyword}-related content`,
        autoGenerated: true,
        memoryIds: [memory.id],
      };
    }

    return null;
  }

  private generateSemanticTags(memory: Memory): Promise<TagSuggestion[]> {
    // Simplified semantic tag generation
    const suggestions: TagSuggestion[] = [];
    const content = memory.content.toLowerCase();

    const semanticPatterns = [
      {
        pattern: /(learn|study|research|investigate)/,
        tag: 'learning',
        confidence: 0.8,
      },
      {
        pattern: /(create|build|develop|implement)/,
        tag: 'creation',
        confidence: 0.8,
      },
      {
        pattern: /(problem|issue|bug|error)/,
        tag: 'troubleshooting',
        confidence: 0.9,
      },
      {
        pattern: /(idea|inspiration|brainstorm)/,
        tag: 'ideation',
        confidence: 0.7,
      },
      {
        pattern: /(meeting|discussion|call)/,
        tag: 'collaboration',
        confidence: 0.85,
      },
    ];

    for (const { pattern, tag, confidence } of semanticPatterns) {
      if (pattern.test(content)) {
        suggestions.push({
          tag,
          confidence,
          reasoning: 'Semantic pattern match',
          frequency: this.getTagFrequency(tag),
          relatedTags: this.getRelatedTags(tag),
        });
      }
    }

    return Promise.resolve(suggestions);
  }

  private generateTemporalTags(memory: Memory): TagSuggestion[] {
    const suggestions: TagSuggestion[] = [];
    const date = new Date(memory.timestamp);

    // Add temporal tags
    const year = date.getFullYear().toString();
    const month = date
      .toLocaleString('default', { month: 'long' })
      .toLowerCase();
    const quarter = `q${Math.ceil((date.getMonth() + 1) / 3)}`;

    suggestions.push(
      {
        tag: year,
        confidence: 0.9,
        reasoning: 'Temporal metadata',
        frequency: this.getTagFrequency(year),
        relatedTags: [],
      },
      {
        tag: month,
        confidence: 0.7,
        reasoning: 'Temporal metadata',
        frequency: this.getTagFrequency(month),
        relatedTags: [],
      },
      {
        tag: quarter,
        confidence: 0.6,
        reasoning: 'Temporal metadata',
        frequency: this.getTagFrequency(quarter),
        relatedTags: [],
      }
    );

    return suggestions;
  }

  private generateBehavioralTags(memory: Memory): TagSuggestion[] {
    const suggestions: TagSuggestion[] = [];

    // Add behavioral tags based on memory type and metadata
    if (memory.type) {
      suggestions.push({
        tag: memory.type,
        confidence: 0.95,
        reasoning: 'Memory type classification',
        frequency: this.getTagFrequency(memory.type),
        relatedTags: [],
      });
    }

    // Add tags based on content length
    const lengthTag =
      memory.content.length > 1000
        ? 'detailed'
        : memory.content.length > 200
          ? 'medium'
          : 'brief';

    suggestions.push({
      tag: lengthTag,
      confidence: 0.6,
      reasoning: 'Content length analysis',
      frequency: this.getTagFrequency(lengthTag),
      relatedTags: [],
    });

    return suggestions;
  }

  private deduplicateTagSuggestions(
    suggestions: TagSuggestion[]
  ): TagSuggestion[] {
    const unique = new Map<string, TagSuggestion>();

    for (const suggestion of suggestions) {
      const existing = unique.get(suggestion.tag);
      if (!existing || existing.confidence < suggestion.confidence) {
        unique.set(suggestion.tag, suggestion);
      }
    }

    return Array.from(unique.values());
  }

  private calculateTagConfidence(tag: string, memory: Memory): number {
    let confidence = 0.5;

    // Boost confidence based on tag frequency in content
    const tagCount = (
      memory.content.toLowerCase().match(new RegExp(tag, 'g')) || []
    ).length;
    confidence += Math.min(tagCount * 0.1, 0.3);

    // Boost confidence based on tag position (earlier = more important)
    const position = memory.content.toLowerCase().indexOf(tag);
    if (position >= 0) {
      const positionScore = 1 - position / memory.content.length;
      confidence += positionScore * 0.2;
    }

    return Math.min(confidence, 1.0);
  }

  private getTagFrequency(tag: string): number {
    const tagSet = this.tagIndex.get(tag);
    return tagSet ? tagSet.size : 0;
  }

  private getRelatedTags(tag: string): string[] {
    // Simplified related tags - would use more sophisticated analysis
    const related = new Map<string, string[]>([
      ['learning', ['education', 'study', 'research']],
      ['creation', ['development', 'building', 'design']],
      ['troubleshooting', ['debugging', 'problem-solving', 'fix']],
      ['ideation', ['creativity', 'brainstorming', 'innovation']],
      ['collaboration', ['teamwork', 'meeting', 'discussion']],
    ]);

    return related.get(tag) || [];
  }

  private findCategoryByName(name: string): string | null {
    for (const [id, category] of this.categories) {
      if (category.name === name) {
        return id;
      }
    }
    return null;
  }

  private generateCategoryName(cluster: {
    centroid: string[];
    memories: Memory[];
  }): string {
    // Use most frequent keyword as category name
    const keywordCounts = new Map<string, number>();

    for (const memory of cluster.memories) {
      const keywords = this.extractKeywords(memory.content);
      for (const keyword of keywords) {
        keywordCounts.set(keyword, (keywordCounts.get(keyword) || 0) + 1);
      }
    }

    const topKeyword = Array.from(keywordCounts.entries()).sort(
      (a, b) => b[1] - a[1]
    )[0];

    return topKeyword ? this.capitalizeFirst(topKeyword[0]) : 'Miscellaneous';
  }

  private async createCategory(categoryData: {
    name: string;
    description: string;
    autoGenerated: boolean;
    memoryIds?: string[];
  }): Promise<string> {
    const id = this.generateId();

    this.categories.set(id, {
      id,
      name: categoryData.name,
      description: categoryData.description,
      children: [],
      memoryCount: categoryData.memoryIds?.length || 0,
      autoGenerated: categoryData.autoGenerated,
      rules: [],
      metadata: {},
    });

    return id;
  }

  private async assignMemoryToCategory(
    memoryId: string,
    categoryId: string
  ): Promise<void> {
    const memory = this.memories.get(memoryId);
    const category = this.categories.get(categoryId);

    if (memory && category) {
      if (!memory.metadata) memory.metadata = {};
      memory.metadata.categoryId = categoryId;
      category.memoryCount++;
    }
  }

  private async addTagToMemory(memoryId: string, tag: string): Promise<void> {
    const memory = this.memories.get(memoryId);

    if (memory) {
      if (!memory.metadata) memory.metadata = {};
      if (!memory.metadata.tags) memory.metadata.tags = [];

      if (!memory.metadata.tags.includes(tag)) {
        memory.metadata.tags.push(tag);

        // Update tag index
        if (!this.tagIndex.has(tag)) {
          this.tagIndex.set(tag, new Set());
        }
        this.tagIndex.get(tag)!.add(memoryId);
      }
    }
  }

  private evaluateCondition(
    value: any,
    operator: string,
    target: any
  ): boolean {
    switch (operator) {
      case 'contains':
        if (Array.isArray(target)) {
          return target.some(t =>
            value.toString().toLowerCase().includes(t.toLowerCase())
          );
        }
        return value.toString().toLowerCase().includes(target.toLowerCase());
      case 'equals':
        return value === target;
      case 'matches':
        return new RegExp(target).test(value.toString());
      case 'greater':
        return Number(value) > Number(target);
      case 'less':
        return Number(value) < Number(target);
      case 'in_range':
        return Number(value) >= target.min && Number(value) <= target.max;
      default:
        return false;
    }
  }

  private getBehavioralMetric(memory: Memory, field: string): any {
    // Return behavioral metrics based on field
    switch (field) {
      case 'access_count':
        return memory.metadata?.accessCount || 0;
      case 'last_accessed':
        return memory.metadata?.lastAccessed || 0;
      case 'modification_count':
        return memory.metadata?.modificationCount || 0;
      default:
        return null;
    }
  }

  private async getPatternValue(memory: Memory, field: string): Promise<any> {
    // Return pattern-based values
    switch (field) {
      case 'keyword_frequency':
        const keywords = this.extractKeywords(memory.content);
        return keywords.length;
      case 'similarity_score':
        return await this.calculateAverageSimilarity(memory);
      default:
        return null;
    }
  }

  private async calculateAverageSimilarity(memory: Memory): Promise<number> {
    const allMemories = Array.from(this.memories.values());
    let totalSimilarity = 0;
    let count = 0;

    for (const otherMemory of allMemories) {
      if (otherMemory.id !== memory.id) {
        totalSimilarity += this.calculateContentSimilarity(memory, otherMemory);
        count++;
      }
    }

    return count > 0 ? totalSimilarity / count : 0;
  }

  private async findDuplicateMemories(memories: Memory[]): Promise<string[]> {
    const duplicates: string[] = [];
    const processed = new Set<string>();

    for (let i = 0; i < memories.length; i++) {
      if (processed.has(memories[i].id)) continue;

      for (let j = i + 1; j < memories.length; j++) {
        if (processed.has(memories[j].id)) continue;

        const similarity = this.calculateContentSimilarity(
          memories[i],
          memories[j]
        );
        if (similarity > 0.9) {
          duplicates.push(memories[j].id);
          processed.add(memories[j].id);
        }
      }
    }

    return duplicates;
  }

  private findOrphanedMemories(memories: Memory[]): string[] {
    return memories
      .filter(memory => !this.getMemoryCategory(memory.id))
      .map(memory => memory.id);
  }

  private async findDenseClusters(memories: Memory[]): Promise<string[][]> {
    const clusters = await this.clusterMemories(memories);
    return clusters
      .filter(cluster => cluster.memories.length >= this.minCategorySize * 2)
      .map(cluster => cluster.memories.map(m => m.id));
  }

  private findOrganizationalGaps(memories: Memory[]): OrganizationInsight[] {
    const insights: OrganizationInsight[] = [];

    // Check for over-populated categories
    for (const [categoryId, category] of this.categories) {
      if (category.memoryCount > 100) {
        insights.push({
          type: 'gap',
          description: `Category "${category.name}" is overcrowded with ${category.memoryCount} memories`,
          memoryIds: this.getCategoryMemories(categoryId).map(m => m.id),
          severity: 'medium',
          recommendation: 'Consider splitting this category into subcategories',
          autoFixAvailable: false,
        });
      }
    }

    return insights;
  }

  private getMemoryCategory(memoryId: string): string | null {
    const memory = this.memories.get(memoryId);
    return memory?.metadata?.categoryId || null;
  }

  private getMemoryTags(memoryId: string): string[] {
    const memory = this.memories.get(memoryId);
    return memory?.metadata?.tags || [];
  }

  private getCategoryMemories(categoryId: string): Memory[] {
    return Array.from(this.memories.values()).filter(
      memory => memory.metadata?.categoryId === categoryId
    );
  }

  private recordOrganizationAction(action: string, memoryIds: string[]): void {
    this.organizationHistory.push({
      timestamp: Date.now(),
      action,
      memoryIds,
    });

    // Keep history size manageable
    if (this.organizationHistory.length > 1000) {
      this.organizationHistory = this.organizationHistory.slice(-500);
    }
  }

  private startAutoOrganization(): void {
    setInterval(async () => {
      const memories = Array.from(this.memories.values());
      if (memories.length > 0) {
        await this.organizeMemories(memories);
      }
    }, this.autoOrganizeInterval);
  }

  // Utility methods
  private generateId(): string {
    return Math.random().toString(36).substring(2) + Date.now().toString(36);
  }

  private capitalizeFirst(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  // Action methods (placeholders for actual implementations)
  private async moveMemory(
    memoryId: string,
    destination: string
  ): Promise<void> {
    const memory = this.memories.get(memoryId);
    if (memory) {
      if (!memory.metadata) memory.metadata = {};
      memory.metadata.location = destination;
    }
  }

  private async archiveMemory(memoryId: string): Promise<void> {
    const memory = this.memories.get(memoryId);
    if (memory) {
      if (!memory.metadata) memory.metadata = {};
      memory.metadata.archived = true;
      memory.metadata.archivedAt = Date.now();
    }
  }

  private async linkMemories(
    sourceId: string,
    targetId: string
  ): Promise<void> {
    const sourceMemory = this.memories.get(sourceId);
    if (sourceMemory) {
      if (!sourceMemory.metadata) sourceMemory.metadata = {};
      if (!sourceMemory.metadata.linkedMemories)
        sourceMemory.metadata.linkedMemories = [];
      if (!sourceMemory.metadata.linkedMemories.includes(targetId)) {
        sourceMemory.metadata.linkedMemories.push(targetId);
      }
    }
  }

  private async setMemoryPriority(
    memoryId: string,
    priority: number
  ): Promise<void> {
    const memory = this.memories.get(memoryId);
    if (memory) {
      if (!memory.metadata) memory.metadata = {};
      memory.metadata.priority = priority;
    }
  }

  /**
   * Public API methods
   */

  /**
   * Get organization overview
   */
  getOrganizationOverview(): {
    categories: Category[];
    rules: OrganizationRule[];
    recentActions: typeof this.organizationHistory;
  } {
    return {
      categories: Array.from(this.categories.values()),
      rules: Array.from(this.organizationRules.values()),
      recentActions: this.organizationHistory.slice(-20),
    };
  }

  /**
   * Add custom organization rule
   */
  addOrganizationRule(rule: Omit<OrganizationRule, 'id'>): string {
    const id = this.generateId();
    this.organizationRules.set(id, { ...rule, id });
    return id;
  }

  /**
   * Update organization rule
   */
  updateOrganizationRule(
    ruleId: string,
    updates: Partial<OrganizationRule>
  ): boolean {
    const rule = this.organizationRules.get(ruleId);
    if (rule) {
      Object.assign(rule, updates);
      return true;
    }
    return false;
  }

  /**
   * Delete organization rule
   */
  deleteOrganizationRule(ruleId: string): boolean {
    return this.organizationRules.delete(ruleId);
  }

  /**
   * Create custom category
   */
  createCustomCategory(
    name: string,
    description: string,
    parentId?: string
  ): string {
    const id = this.generateId();

    this.categories.set(id, {
      id,
      name,
      description,
      parentId,
      children: [],
      memoryCount: 0,
      autoGenerated: false,
      rules: [],
      metadata: {},
    });

    // Update parent if specified
    if (parentId) {
      const parent = this.categories.get(parentId);
      if (parent) {
        parent.children.push(id);
      }
    }

    return id;
  }

  /**
   * Delete category
   */
  deleteCategory(categoryId: string): boolean {
    const category = this.categories.get(categoryId);
    if (category) {
      // Move memories to uncategorized
      const categoryMemories = this.getCategoryMemories(categoryId);
      for (const memory of categoryMemories) {
        if (memory.metadata) {
          delete memory.metadata.categoryId;
        }
      }

      // Remove from parent
      if (category.parentId) {
        const parent = this.categories.get(category.parentId);
        if (parent) {
          parent.children = parent.children.filter(id => id !== categoryId);
        }
      }

      return this.categories.delete(categoryId);
    }
    return false;
  }

  /**
   * Get category hierarchy
   */
  getCategoryHierarchy(): Array<Category & { depth: number }> {
    const hierarchy: Array<Category & { depth: number }> = [];

    const addCategory = (categoryId: string, depth: number = 0) => {
      const category = this.categories.get(categoryId);
      if (category) {
        hierarchy.push({ ...category, depth });
        for (const childId of category.children) {
          addCategory(childId, depth + 1);
        }
      }
    };

    // Start with root categories (no parent)
    for (const category of this.categories.values()) {
      if (!category.parentId) {
        addCategory(category.id);
      }
    }

    return hierarchy;
  }

  /**
   * Export organization configuration
   */
  exportConfiguration(): {
    categories: Category[];
    rules: OrganizationRule[];
    settings: {
      autoOrganizeInterval: number;
      minCategorySize: number;
      maxCategories: number;
      confidenceThreshold: number;
    };
  } {
    return {
      categories: Array.from(this.categories.values()),
      rules: Array.from(this.organizationRules.values()),
      settings: {
        autoOrganizeInterval: this.autoOrganizeInterval,
        minCategorySize: this.minCategorySize,
        maxCategories: this.maxCategories,
        confidenceThreshold: this.confidenceThreshold,
      },
    };
  }

  /**
   * Import organization configuration
   */
  importConfiguration(config: {
    categories?: Category[];
    rules?: OrganizationRule[];
    settings?: Partial<{
      autoOrganizeInterval: number;
      minCategorySize: number;
      maxCategories: number;
      confidenceThreshold: number;
    }>;
  }): void {
    if (config.categories) {
      this.categories.clear();
      for (const category of config.categories) {
        this.categories.set(category.id, category);
      }
    }

    if (config.rules) {
      this.organizationRules.clear();
      for (const rule of config.rules) {
        this.organizationRules.set(rule.id, rule);
      }
    }

    if (config.settings) {
      if (config.settings.autoOrganizeInterval !== undefined) {
        this.autoOrganizeInterval = config.settings.autoOrganizeInterval;
      }
      if (config.settings.minCategorySize !== undefined) {
        this.minCategorySize = config.settings.minCategorySize;
      }
      if (config.settings.maxCategories !== undefined) {
        this.maxCategories = config.settings.maxCategories;
      }
      if (config.settings.confidenceThreshold !== undefined) {
        this.confidenceThreshold = config.settings.confidenceThreshold;
      }
    }
  }
}

export default AutomaticOrganization;
